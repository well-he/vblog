(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{841:function(e,a,t){"use strict";t.r(a);var r=t(40),c=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"docker-基本知识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-基本知识"}},[e._v("#")]),e._v(" docker 基本知识")]),e._v(" "),t("h3",{attrs:{id:"镜像-image-文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#镜像-image-文件"}},[e._v("#")]),e._v(" 镜像(image)文件")]),e._v(" "),t("ol",[t("li",[e._v("docker 把应用程序及其依赖，打包在 image 文件里面")]),e._v(" "),t("li",[e._v("image 文件可以看做是容器的模板，docker 根据 image 文件生成容器的实例")]),e._v(" "),t("li",[e._v("同一个 image 文件，可以生成多个同时运行的模板")]),e._v(" "),t("li",[t("code",[e._v("docker image pull")]),e._v(" 是抓取 image 文件的命令 (eg: "),t("code",[e._v("docker image pull hello-world")]),e._v(")")]),e._v(" "),t("li",[e._v("使用"),t("code",[e._v("docker image ls")]),e._v("查看本机下面的已有的 docker image 文件")]),e._v(" "),t("li",[e._v("运行 image 文件:"),t("code",[e._v("docker container run hello-world")]),e._v(",该命令会从 image 文件，生成一个正在运行的容器实例")]),e._v(" "),t("li",[e._v("终止正在运行的容器: "),t("code",[e._v("docker container kill [containID]")])])]),e._v(" "),t("h3",{attrs:{id:"容器-container-文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器-container-文件"}},[e._v("#")]),e._v(" 容器(container)文件")]),e._v(" "),t("ol",[t("li",[e._v("容器文件指的是 image 文件生成的容器实例")]),e._v(" "),t("li",[e._v("关闭容器不会删除容器，只会停止运行")]),e._v(" "),t("li",[e._v("查看本机正在运行的容器: "),t("code",[e._v("docker container ls")])]),e._v(" "),t("li",[e._v("查看本机所有的容器(运行和非运行): "),t("code",[e._v("docker container ls --all")])]),e._v(" "),t("li",[e._v("删除容器: "),t("code",[e._v("docker container rm [containerID]")])])]),e._v(" "),t("h3",{attrs:{id:"dcokerfile-文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dcokerfile-文件"}},[e._v("#")]),e._v(" Dcokerfile 文件")]),e._v(" "),t("p",[e._v("用来配置 image 的文本文件。 Docker 会根据该文件生成二进制的 image 文件。\n写 Dockerfile 文件的步骤:")]),e._v(" "),t("ol",[t("li",[e._v("先 clone 自己的项目: "),t("code",[e._v("git clone xxxx")]),e._v(";")]),e._v(" "),t("li",[e._v("在项目的根目录下，新建一个文本文件:"),t("code",[e._v(".dockerignore")]),e._v(":")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(".git\n node_modules\n npm-debug.log\n")])])]),t("p",[e._v("该文件会排除以上的三个路径下的文件，告诉 docker 不要将这三个打包到 image 文件。")]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("在项目的根目录下，新建一个文本文件"),t("code",[e._v("Dockerfile")]),e._v(":")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  FROM node:8.4       //指定node的版本\n  COPY . /app        //将当前目录下的所有文件，都拷贝至iamge文件的/app目录\n  WORKDIR /app       // 指定接下来的工作路径为/app\n  RUN npm install --registry=https://registry.npm.taobao.org  // 在/app目录下，运行npm intall 安装项目依赖，这些依赖都会被打包进image文件\n  EXPOSE 3000        //将容器的3000端口暴露出来，允许外部连接\n")])])]),t("h3",{attrs:{id:"创建-image-文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建-image-文件"}},[e._v("#")]),e._v(" 创建 image 文件")]),e._v(" "),t("p",[e._v("有了 Dockerfile 文件之后，就可以使用 "),t("code",[e._v("docker iamge build")]),e._v(" 命令来创建 image 文件了。\n创建命令:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker image build -t [imageName] .\n")])])]),t("p",[e._v("或者:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker image build -t [imageName]:0.0.1 .\n")])])]),t("p",[t("code",[e._v("-t")]),e._v(" 指定文件 image 文件的名字， 最后那个点则是 Dockerfile 文件所在的路径，还可以使用"),t("code",[e._v(":")]),e._v("来指定标签\n执行完成之后，查看当前 image 文件: "),t("code",[e._v("docker image ls")])]),e._v(" "),t("h3",{attrs:{id:"生成容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成容器"}},[e._v("#")]),e._v(" 生成容器")]),e._v(" "),t("p",[t("code",[e._v("docker container run")]),e._v(" 命令会从 image 文件生成容器:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" docker run -p 8000:3000 -it [iamgeName] /bin/bash\n")])])]),t("p",[e._v("或者:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" docker run -p 8000:3000 -it [iamgeName]:0.0.1 /bin/bash\n")])])]),t("p",[e._v("或者:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker run -p 3000:80 -d --name [containerName] [iamgeName]\n")])])]),t("p",[t("code",[e._v("-p")]),e._v("参数: 容器的 3000 端口映射到本机的 8000 端口")]),e._v(" "),t("p",[t("code",[e._v("-it")]),e._v("参数: 容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入到容器")]),e._v(" "),t("p",[t("code",[e._v("-d")]),e._v("参数: 让容器在后台运行")]),e._v(" "),t("p",[t("code",[e._v("--name")]),e._v("参数: 指定容器名称")]),e._v(" "),t("p",[t("code",[e._v("/bin/bash")]),e._v("参数: 容器启动以后，内部第一个执行的命令，这里是启动 Bash，保证用户可以使用 Shell\n当跑完这些命令的时候，会返回一个命令行提示符，然后就可以在里面执行命令了")]),e._v(" "),t("h3",{attrs:{id:"其他有用的命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他有用的命令"}},[e._v("#")]),e._v(" 其他有用的命令")]),e._v(" "),t("p",[e._v("（1）"),t("code",[e._v("docker container start")]),t("br"),e._v("\n前面的 docker container run 命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用 docker container start 命令，它用来启动已经生成、已经停止运行的容器文件:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("   docker container start [containerID]\n")])])]),t("p",[e._v("（2）"),t("code",[e._v("docker container stop")]),t("br"),e._v("\n前面的 docker container kill 命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而 docker container stop 命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("   bash container stop [containerID]\n")])])]),t("p",[e._v("这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。")]),e._v(" "),t("p",[e._v("（3）"),t("code",[e._v("docker container logs")])]),e._v(" "),t("p",[t("code",[e._v("docker container logs")]),e._v(" 命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果 docker run 命令运行容器的时候，没有使用-it 参数，就要用这个命令查看输出。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    docker container logs [containerID]\n")])])]),t("p",[e._v("（4）"),t("code",[e._v("docker container exec")])]),e._v(" "),t("p",[t("code",[e._v("docker container exec")]),e._v(" 命令用于进入一个正在运行的 docker 容器。如果 docker run 命令运行容器的时候，没有使用-it 参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker container exec -it [containerID] /bin/bash\n")])])]),t("p",[e._v("（5）"),t("code",[e._v("docker container cp")])]),e._v(" "),t("p",[t("code",[e._v("docker container cp")]),e._v(" 命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker container cp [containID]:[/path/to/file]\n")])])]),t("h3",{attrs:{id:"docker-compose-工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-compose-工具"}},[e._v("#")]),e._v(" Docker Compose 工具")]),e._v(" "),t("p",[e._v("Compose 可以管理多个 Docker 容器组成一个应用。定义一个 "),t("code",[e._v(".yaml")]),e._v("的配置文件 "),t("code",[e._v("docker-compose.yml")]),e._v(",在这个文件里面写好多个容器之间的调用关系。然后只要一个命令，即可同时启动/关闭这些容器:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker-compose up   //启动所有服务\ndocker-compose stop //关闭所有服务\ndocker-compose rm   // 删除所有容器\n")])])]),t("h3",{attrs:{id:"docker-更改镜像加速器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-更改镜像加速器"}},[e._v("#")]),e._v(" docker 更改镜像加速器")]),e._v(" "),t("p",[e._v("进入 "),t("code",[e._v("/etc/docker/daemon.json")]),e._v(" 里面编辑(没有这个文件请新建):")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n  "registry-mirrors": [\n    "https://dockerhub.azk8s.cn",\n    "https://reg-mirror.qiniu.com"\n  ]\n}\n')])])]),t("p",[e._v("然后重启 docker 即可:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ sudo systemctl daemon-reload\n$ sudo systemctl restart docker\n")])])]),t("p",[e._v("然后执行 "),t("code",[e._v("docker info")]),e._v(" 查看配置是否生效")]),e._v(" "),t("h3",{attrs:{id:"需要继续深入学习的东西"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#需要继续深入学习的东西"}},[e._v("#")]),e._v(" 需要继续深入学习的东西")]),e._v(" "),t("ol",[t("li",[e._v("Dockerfile 文件的编写")]),e._v(" "),t("li",[e._v("docker-compose.yaml 的编写")])]),e._v(" "),t("h3",{attrs:{id:"现在的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#现在的问题"}},[e._v("#")]),e._v(" 现在的问题")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("是不是写了 Dockerfile 文件之后，在服务器直接拉取代码，然后根据 Dcokerfile 制作项目 image，如果是 vue 项目，是否就不用打包了？因为只需根据 Dockerfile 制作的 image 启动容器即可。")]),e._v(" "),t("p",[e._v("我的看法：应当还是要打包的，但是打包操作是在 Dockerfile 文件里面执行吗？或者还有一种思路，就是先在本地打包，并把 Dcokerfile 也打包进 dist 目录，在服务器上拉取代码，然后进入 dist 目录，再根据 Dockerfile 文件制作 image？")])]),e._v(" "),t("li",[t("p",[e._v("如何利用 "),t("code",[e._v("docker-compose")]),e._v(" 将 vue 前台服务和后台服务写到同一个 image 里面？(前台和后台是分开的，前台的请求会反向代理到后台，后台为一个 Node.js 服务，不涉及到数据库。等于说，前台服务需要 nginx，后台则需要 node)")])])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("如何实现以下的 docker 编排？")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://i.loli.net/2019/08/20/ZTr3s1CbV7vG9Bq.png",alt:"docker服务编排.png"}})]),e._v(" "),t("h3",{attrs:{id:"查看-container-的-ip-地址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看-container-的-ip-地址"}},[e._v("#")]),e._v(" 查看 container 的 IP 地址")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker exect -it [containerName] bash\ncat /etc/hosts\n")])])]),t("p",[e._v("或者直接使用 "),t("code",[e._v("docker inspect [containerName]")]),e._v(" 查看 IP 地址")])])}),[],!1,null,null,null);a.default=c.exports}}]);