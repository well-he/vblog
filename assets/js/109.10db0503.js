(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{845:function(e,t,a){"use strict";a.r(t);var s=a(40),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Gitflow是一个基于feature分支管理的版本发布方案。它是由荷兰程序猿Vincent Driessen设计研发，开源项目地址gitflow-avh。\n大致流程是：")]),e._v(" "),a("ul",[a("li",[e._v("不同feature在不同feature分支上单独开发(或测试)。")]),e._v(" "),a("li",[e._v("确定版本号和此版本将要发布的功能后，将相应featustre分支统一向develop分支合并，然后拉出新的release预发布分支。")]),e._v(" "),a("li",[e._v("release分支作为持续集成关注的分支，修复bug。")]),e._v(" "),a("li",[e._v("待release分支测试验收通过后，统一向master分支和develop分支合并，并在master分支打tag。")]),e._v(" "),a("li",[e._v("根据tag发布apk版本。")])]),e._v(" "),a("p",[e._v("若线上发现严重bug，需走hotfix流程。")]),e._v(" "),a("ul",[a("li",[e._v("基于master分支拉出hotfix分支修复线上问题。")]),e._v(" "),a("li",[e._v("bug修复完成统一向master和develop分支合并。")]),e._v(" "),a("li",[e._v("master分支打上新的tag，发布新版本。")])]),e._v(" "),a("p",[e._v("下面将介绍如何使用Gitflow命令完成上述版本发布，一条Gitflow指令可能对应了一系列git命令，为的是规范化开发流程，提高代码管理效率。")]),e._v(" "),a("h3",{attrs:{id:"mac平台安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mac平台安装"}},[e._v("#")]),e._v(" Mac平台安装")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("brew install git-flow\n")])])]),a("p",[e._v("brew表示Homebrew，它是mac平台常用的包管理器，没有安装则需先安装，安装可参考Mac OS下brew的安装和使用。")]),e._v(" "),a("h3",{attrs:{id:"初始化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[e._v("#")]),e._v(" 初始化")]),e._v(" "),a("p",[e._v("先将远程仓库克隆到本地。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git clone <project_url>\n")])])]),a("p",[e._v("各种初始化Gitflow配置。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow init\n")])])]),a("p",[e._v("命令行会提示你是否修改Gitflow提供的默认分支前缀。不同场景的分支前缀不同，默认情况下分支前缀是这样的：")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("场景")]),e._v(" "),a("th",[e._v("分支前缀")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("新功能")]),e._v(" "),a("td",[e._v("feature")])]),e._v(" "),a("tr",[a("td",[e._v("预发布")]),e._v(" "),a("td",[e._v("release")])]),e._v(" "),a("tr",[a("td",[e._v("热修复")]),e._v(" "),a("td",[e._v("hotfix")])]),e._v(" "),a("tr",[a("td",[e._v("打tag")]),e._v(" "),a("td",[e._v("空")])])])]),e._v(" "),a("p",[e._v("分支前缀的作用是区分不同分支的使用场景，同时当你使用Gitflow命令时就不需手动添加分支前缀了，Gitflow会帮你加上。\n比如开发新功能需创建一个feature分支，名为gitworkflow，使用下面的代码将会创建一个名为feature/gitworkflow本地分支。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow feature start gitworkflow\n")])])]),a("p",[e._v("通常情况下不需要修改默认的命名前缀，只需加上-d就可跳过修改命名阶段。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow init -d\n")])])]),a("h3",{attrs:{id:"行为-action"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行为-action"}},[e._v("#")]),e._v(" 行为/Action")]),e._v(" "),a("p",[e._v("通常来说，一种场景的完整生命周期应至少包含以下几种行为：")]),e._v(" "),a("ul",[a("li",[e._v("start 开始开发")]),e._v(" "),a("li",[e._v("publish 发布到远程分支")]),e._v(" "),a("li",[e._v("finish 完成开发、合并到主分支")])]),e._v(" "),a("p",[e._v("我们首先以feature场景为例，看看如何完成工作流。")]),e._v(" "),a("h3",{attrs:{id:"feature流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#feature流程"}},[e._v("#")]),e._v(" feature流程")]),e._v(" "),a("h4",{attrs:{id:"start"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#start"}},[e._v("#")]),e._v(" start")]),e._v(" "),a("p",[e._v("新功能开始开发前，需准备好开发分支。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow feature start <feature_name>\n")])])]),a("p",[e._v("执行上面的命令将会在本地创建名为<feature_name>的分支，并切换到该分支，而且不论当前所处哪个分支都是基于develop分支创建，相当于执行了下面的git的命令。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git checkout -b feature/<feature_name> develop\n")])])]),a("p",[e._v("需要注意基于的是本地的develop分支，执行此命令前一般需要拉取最新的远程代码。")]),e._v(" "),a("h4",{attrs:{id:"publish"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#publish"}},[e._v("#")]),e._v(" publish")]),e._v(" "),a("p",[e._v("在本地开发完成新功能并commit后，需要将本地代码push到远程仓库。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow feature publish <feature_name>\n")])])]),a("p",[e._v("这行指令做了三件事。")]),e._v(" "),a("ul",[a("li",[e._v("创建一个名为feature/<feature_name>的远程分支。")]),e._v(" "),a("li",[e._v("本地分支track上述远程分支。")]),e._v(" "),a("li",[e._v("如果本地有未push代码，则执行push。")])]),e._v(" "),a("p",[e._v("转换成git命令就是下面的样子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git push origin feature/<feature_name>\ngit push --set-upstream origin feature/<feature_name>\ngit push origin\n")])])]),a("p",[e._v("注意：如果已经执行过publish后又有新的代码需push，再次执行将报错，因为它始终会试图创建一个远程分支。此时需执行正常的push命令git push origin。")]),e._v(" "),a("h4",{attrs:{id:"finish"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#finish"}},[e._v("#")]),e._v(" finish")]),e._v(" "),a("p",[e._v("当功能开发完毕后就将进入测试阶段，此时需将一个或多个feature分支统一合并到develop分支。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow feature finish <feature_name>\n")])])]),a("p",[e._v("这行指令也做了三件事。")]),e._v(" "),a("ul",[a("li",[e._v("切换到develop分支。")]),e._v(" "),a("li",[e._v("合并代码到develop分支")]),e._v(" "),a("li",[e._v("删除本地feature/<feature_name>分支。\n等价于执行下面的git命令：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git checkout develop\ngit merge feature/<feature_name>\ngit branch -d feature/<feature_name>\n")])])]),a("p",[e._v("如果merge时发生了冲突，则在第二步merge时终止流程，即不会再删除本地分支。但当前已处于develop分支，待本地冲突解决并commit后，重新执行"),a("code",[e._v("git flow feature finish <feature_name>")]),e._v("即可完成finish流程。\n细心的同学可以已经发现finish还有两件事没做。")]),e._v(" "),a("ul",[a("li",[e._v("develop分支代码还未push。")]),e._v(" "),a("li",[e._v("未删除远程分支feature/<feature_name>。")])]),e._v(" "),a("p",[e._v("也就是还需执行")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git push origin develop\ngit push origin :feature/<feature_name>\n")])])]),a("h3",{attrs:{id:"release流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#release流程"}},[e._v("#")]),e._v(" release流程")]),e._v(" "),a("p",[e._v("当新功能开发完毕，将进入测试阶段，此时需要基于develop分支拉出release分支进行集成测试，也有将release场景作为预发布环境进行测试的，即feature场景已完成常规测试，在这种情况下，一般而言release只有少数改动。在这里我们先不讨论项目流程问题。\n使用start指令开启一个release场景，通常以版本号命令，我们以v2.0为例：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow release start v2.0\n")])])]),a("p",[e._v("此命令会基于本地的develop分支创建一个release/v2.0分支，并切换到这个分支上。\n为了让其他协同人员也能看到此分支，需要将其发布出去。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow release publish v2.0\n")])])]),a("p",[e._v("以上和feature场景十分类似。\n待测试通过需要发布正式版：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow release finish v2.0\n")])])]),a("p",[e._v("这一步做的动作有点多，大致是：")]),e._v(" "),a("ul",[a("li",[e._v("git fetch")]),e._v(" "),a("li",[e._v("release/v2.0分支代码向master合并。")]),e._v(" "),a("li",[e._v("生成名为v2.0的tag。")]),e._v(" "),a("li",[e._v("release/v2.0分支代码向develop合并。")]),e._v(" "),a("li",[e._v("删除本地release/v2.0分支。")]),e._v(" "),a("li",[e._v("切换回develop分支。")])]),e._v(" "),a("p",[e._v("如果merge产生冲突不会终止流程，只是不会将本地的release分支删除，待解决完冲突后需再次执行finish指令。\n另外需要注意的是，如果本地还有未finish的release分支，将不允许使用start指令开启新的release分支，这一点是对并行发布的一个限制。\nrelease finish只是完成了本地代码的一系列操作，还需要同步到远程仓库。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git push origin develop\ngit push origin master\ngit push origin v2.0\n")])])]),a("p",[e._v("或者使用下面的命令推送所有的分支和tag。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git push origin --all\ngit push origin --tags\n")])])]),a("h3",{attrs:{id:"hotfix-流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hotfix-流程"}},[e._v("#")]),e._v(" hotfix 流程")]),e._v(" "),a("p",[e._v("当tag打完，也表示正式版本发布出去了，如果此时在线上发现了严重的bug，需要进行紧急修复。\n此时我们假设版本号变为v2.0-patch。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow hotfix start v2.0-patch\n")])])]),a("p",[e._v("这将创建一个hotfix/v2.0本地分支并切换到该分支。 hotfix没有publish指令，认为hotfix应该是个小范围改动，不需要其他协同人员参与。\n待本地修改结束commit后，执行finish指令。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git flow hotfix finish v2.0-patch\n")])])]),a("p",[e._v("按照Gitflow工作流，它会执行下面的任务，与release基本一致。")]),e._v(" "),a("ul",[a("li",[e._v("git fetch")]),e._v(" "),a("li",[e._v("hotfix/v2.0-patch分支代码向master合并。")]),e._v(" "),a("li",[e._v("生成名为v2.0-patch的tag。")]),e._v(" "),a("li",[e._v("hotfix/v2.0-patch分支代码向develop合并。")]),e._v(" "),a("li",[e._v("删除本地hotfix/v2.0-patch分支。")]),e._v(" "),a("li",[e._v("切换回develop分支。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);